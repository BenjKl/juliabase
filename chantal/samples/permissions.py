#!/usr/bin/env python
# -*- coding: utf-8 -*-

u"""Central permission checking.  This module consists of three parts: First,
the exceptions that are raised if a certain permission condition is not met.
Secondly, the assertion functions that test for certain permissions.  And
thirdly, top-level code that generates a ``has_permission_to_...`` function for
every ``assert_can_...`` function.

The idea is the following.  For example, there is a function called
``assert_can_view_sample``.  If the user can't view the sample, a
``PermissionViewSampleError`` is raised.  Sometimes however, you just want to
check it without having to catch an exception.  Then, you use
``has_permission_to_view_sample``.  The parameters are the same but instead of
raising an exception, it returns ``True`` or ``False``.

The ``assert_can_...`` function are typically used at the beginning of views
where permissions need to be checked and every failure means an error.  By
contrast, the ``has_permission_to_...`` functions are used where a missing
permission just means that e.g. a link is not generated (for example, in the
``get_additional_template_context`` methods in the models).
"""

from django.utils.translation import ugettext as _, ugettext_lazy
import django.contrib.auth.models
# Attention! This is a cyclic import.  Don't use models in top-level code.
from chantal.samples import models
from chantal.samples.views import shared_utils

_ = ugettext_lazy
translate_permission = {"Can add an external operator": _("Can add an external operator"),
                        "Can create and edit 6-chamber depositions": _("Can create and edit 6-chamber depositions"),
                        "Can create and edit hall measurements": _("Can create and edit hall measurements"),
                        "Can create and edit large-area depositions": _("Can create and edit large-area depositions"),
                        "Can create and edit PDS measurements": _("Can create and edit PDS measurements"),
                        "Can view all samples (senior user)": _("Can view all samples (senior user)"),
                        "Can edit group memberships": _("Can edit group memberships"),
                        }
_ = ugettext

class PermissionError(Exception):
    u"""Common base class for all permission exceptions.  It should never be
    instantiated itself.

    Note that I store much in instance attributes.  For example, the user whose
    permissions are not enough should be the currently logged-in user anyway,
    so it seems to be superfluous to store it in an attribute, too.  The sample
    is true for ``message`` (generated by calling the inherited contructor) and
    some attributes stored by derived classes.  However, you never know, and I
    like fat exception objects.

    :ivar decription: the full description of what failed.  It should be a
      complete sentence, which addresses the user directly.  It should start
      with a capital letter and end with a full stop.  For example, it may
      contain ``"You are not allowed to view sample 01B-410."``.

      Typically, this is generated by the exception's class constructor.
      However, the class constructor only generates a *partial* phrase which is
      then embedded into a pattern sentence in `PermissionError.__init__`.

    :ivar reason: the full reason why the permission was missing.  It should be
      a complete sentence, starting with a capital letter and ending with a
      full stop.  It should address the user directly.  For example, it may
      contain ``"You are not in group “SiC”."``.  Avoid giving more information
      here than the user is allowed to know.  Typically, this is generated by
      the assertion function.

    :type description: unicode
    :type reason: unicode
    """
    def __init__(self, user, partial_description, reason, reason_is_permission=False, group_would_help=False):
        u"""Class constructor.  The only difficult thing here is
        ``partial_description``.  It is embedded into another string to form a
        complete sentence.  The embracing string for English is ``"You are not
        allowed to <partial_description>."``.  For other languages it may
        differ.  The partial description must fit into it, e.g., it may be
        ``"view sample 01B-410"``.

        :Parameters:
          - `user`: the user which has too few permissions
          - `partial_description`: a sentence fragment describing the denied
            action
          - `reason`: the reason why the permission could not be granted.  Must
            be a full sentence with punctuation.

        :type user: ``django.contrib.auth.models.User``
        :type partial_description: unicode
        :type reason: unicode
        """
        self.description = _(u"You are not allowed to %s.") % partial_description
        super(PermissionError, self).__init__(_(u"%(description)s  Reason: %(reason)s") %
                                              {"description": self.description, "reason": reason})
        if reason_is_permission:
            reason = translate_permission[django.contrib.auth.models.Permission.objects.get(codename=reason).name]
        self.user, self.reason, self.reason_is_permission, self.group_would_help = \
            user, reason, reason_is_permission, group_would_help

class PermissionViewSampleError(PermissionError):
    def __init__(self, user, sample, reason):
        super(PermissionViewSampleError, self).__init__(user, _(u"view sample %s") % sample, reason)
        self.sample = sample

def assert_can_view_sample(user, sample):
    u"""Tests whether the user can view the sample.

    :Parameters:
      - `user`: ``django.contrib.auth.models.User``
      - `sample`: `models.Sample`

    :Exceptions:
      - `PermissionViewSampleError`: raised if the user is not allowed to view
        the sample.
    """
    if not user.has_perm("samples.view_all_samples") and sample.group not in user.groups.all() \
            and sample.currently_responsible_person != user:
        raise PermissionViewSampleError(user, sample, _(u"You are not in the sample's group, nor are you its currently "
                                                        u"responsible person, nor are you a senior user."))


class PermissionEditSampleError(PermissionError):
    def __init__(self, user, sample, reason):
        super(PermissionViewSampleError, self).__init__(user, _(u"edit sample %s") % sample, reason)
        self.sample = sample

def assert_can_edit_sample(user, sample):
    u"""Tests whether the user can edit the sample.

    :Parameters:
      - `user`: ``django.contrib.auth.models.User``
      - `sample`: `models.Sample`

    :Exceptions:
      - `PermissionEditSampleError`: raised if the user is not allowed to edit
        the sample.
    """
    if sample.currently_responsible_person != user:
        raise PermissionEditSampleError(user, sample, _(u"You are not the sample's currently responsible person."))


class PermissionAddEditPhysicalProcessError(PermissionError):
    def __init__(self, user, process_class, process, reason):
        if process:
            partial_description = _(u"edit the process “%s”") % unicode(process)
        else:
            partial_description = _(u"add %s") % process_class._meta.verbose_name_plural
        super(PermissionAddEditPhysicalProcessError, self).__init__(user, partial_description, reason)
        self.process_class, self.process = process_class, process

def assert_can_add_edit_physical_process(user, process_class, process):
    u"""Tests whether the user can create or edit a physical process
    (i.e. deposition, measurement, etching process, clean room work etc).

    :Parameters:
      - `user`: ``django.contrib.auth.models.User``
      - `process_class`: ``class`` (derived from `models.Process`)

    :Exceptions:
      - `PermissionAddEditPhysicalProcessError`: raised if the user is not
        allowed to create or edit the process.
    """
    permission = "samples.add_edit_" + shared_utils.camel_case_to_underscores(process_class.__name__)
    if not user.has_perm(permission) or True:
        raise PermissionAddEditPhysicalProcessError(
            user, process_class, process,
            _(u"You don't have the special right to add or edit %s.") % process_class._meta.verbose_name_plural)


# Now, I inject the ``has_permission_to_...`` functions into this module for
# for every ``assert_can_...`` function found here.

def generate_permission_function(assert_func):
    def has_permission(*args, **keyw):
        try:
            assert_func(*args, **keyw)
        except PermissionError:
            return False
        else:
            return True
    return has_permission
import copy, inspect
_globals = copy.copy(globals())
all_assertion_functions = [func for func in _globals.values()
                           if inspect.isfunction(func) and func.__name__.startswith("assert_can_")]
for func in all_assertion_functions:
    new_name = "has_permission_to_" + func.__name__[len("assert_can_"):]
    globals()[new_name] = generate_permission_function(func)
