.. -*- mode: rst; coding: utf-8; ispell-local-dictionary: "british" -*-
..
.. This file is part of JuliaBase, the samples database.
..
.. Copyright © 2008–2014 Forschungszentrum Jülich, Germany,
..                       Marvin Goblet <m.goblet@fz-juelich.de>,
..                       Torsten Bronger <t.bronger@fz-juelich.de>
..
.. You must not use, install, pass on, offer, sell, analyse, modify, or
.. distribute this software without explicit permission of the copyright
.. holder.  If you have received a copy of this software without the explicit
.. permission of the copyright holder, you must destroy it immediately and
.. completely.

===============
Programming
===============


This document explains JuliaBase for the programmer who wants to adapt it to
their institute, research department, or scientific group.  It contains an
overview of the process as a whole, and refers to other pages with the details.
We hope that it serves as a gentle tutorial which makes the adaption process as
easy as possible.  Feedback is welcomed!

For the adaption process, you should be familiar with several technologies:

1.  *Python*.  You should have advanced experience in this language.  This
    includes the standard library; you should at least know what it can do and
    how to find information about it.

2.  *Django*.  You must have mastered the tutorial of the Django web framework.

3.  *HTML*.  Basic knowledge should be enough.

Furthermode, some admin skills are necessary to get everything running.


.. _Organizing your source code:

Organizing your source code
===============================

It would be a bad idea to download JuliaBase's source code and modify it
directly to your needs because then, any JuliaBase update would destroy your
changes.  Instead, you make a structure according to this::

    myproject/
        manage.py
        juliabase/
            {the original JuliaBase release}
        mysite/
            __init__.py
            settings.py
            urls.py
            wsgi.py
        institute/
            __init__.py
            admin.py
            urls.py
            migrations/
            models/
            static/
            templates/
            views/
            ...

Thus, follow these steps:

#. Create the directory :file:`myproject/`
#. Copy a JuliaBase release to :file:`myproject/juliabase`
#. Copy the file :file:`myproject/juliabase/manage.py` to :file:`myproject/`.
#. Create :file:`myproject/mysite/`
#. Copy the files :file:`settings.py`, :file:`urls.py`, and :file:`wsgi.py`
   from :file:`myproject/juliabase/` to :file:`myproject/mysite/`
#. Create an empty file :file:`myproject/mysite/__init__.py`
#. Copy recursively the directory :file:`myproject/juliabase/institute` to
   :file:`myproject/`.


Git subtree
-----------

If you're using Git, you may consider using the ``subtree`` command to get
JuliaBase in your repo: You structure your repository like above but without
the :file:`juliabase` subdirectory.  Then, you say::

    git subtree add --prefix juliabase --squash git@bob.ipv.kfa-juelich.de:juliabase v1.0

A new version is pulled into your repo with::

    git subtree pull --prefix juliabase --squash git@bob.ipv.kfa-juelich.de:juliabase v2.0


Creating a new Django app
=============================

Okay, now let's dive into the serious stuff.

You created your Django project, you added JuliaBase to it as explained in
`Organizing your source code`_.  Furthermore, you set up everything as
explained in :doc:`installation` (Apache is not yet needed).  Let's
try to get it running with

.. code-block:: shell-session

    username@server:~/mysite$ ./manage.py migrate
    username@server:~/mysite$ ./manage.py loaddata demo
    username@server:~/mysite$ ./manage.py collectstatic
    username@server:~/mysite$ ./manage.py runserver

This should make the site accessible locally at the URL http://127.0.0.1:8000.


The institute app that is used is :file:`myproject/institute`.  For far, it is
a 1:1 copy of the JuliaBase app of the same name.  The plan is to transform it
into what *you* need by pruning and modifying it.  The primary tasks when
adapting the app to your group or institution are:

1. Branding.
2. Adapting the “add new samples” page.
3. Manage the physical processes.


Branding
--------

For the time being, we will stay with the app name “institute” to keep the
number of changes small.  Remember that it is only the app name; you may
rebrand the wabpages to whatever you like.  The central point of doing so is
:file:`institute/templates/jb_base.html`.  There, you may change the name of
the institution as well as its logo.  The logo file should be placed in
:file:`institute/static/institute/`.

Moreover, every JuliaBase installation must have at least one department.  It
needs to be created only once and should be named appropriately.


The “add new samples” view
--------------------------

JuliaBase respects that creating new samples is a rather institute-specific
procedure and therefore does not include a view for this.  Instead, you must
create one, but you may use the INM's view in
:file:`institute/views/samples/sample.py` as a comprehensive starting point (in
particular, the function :py:func:`institute.views.samples.sample.add`).

In the INM, every sample starts its life with a *substrate*.  This is a
physical process that is always the very first one in the sample's history.
Therefore, the web page where you can add new samples also asks for the
substrate data, and creates the samples together with their substrates.  You
may or may not wish to have substrates, too.

The second big issue is sample names.  Most institutions have quite
ideosycratic ideas about the sample naming policy.  But JuliaBase is very
flexible regarding this, see :doc:`sample_names`.  In the “add new samples”
view, you may let the user input (a pattern for) the new samples right away, or
you may give the names totally automatically.  Or, you may do it similarly to
the INM: Let the user decide between some options, and possibly redirect to a
bulk-rename view after having added the samples with provisional names.


Physical processes
------------------

Physical processes are the thing that a JuliaBase programmer will spend most of
its time on.  They represent everything physically available in your
institution: Measurement setups, deposition setups, clean room processes,
chemical treatment, etc.

The INM app “institute” ships with some examples.  You may convert them to what
you need, but you can also remove them.  For the latter, visit
:file:`institute/urls.py` and have a look at the following part (at the
bottom)::

    pattern_generator = PatternGenerator(urlpatterns, "institute.views.samples")
    pattern_generator.deposition("ClusterToolDeposition", views={"add", "edit"})
    pattern_generator.deposition("FiveChamberDeposition", "5-chamber_depositions")
    pattern_generator.physical_process("PDSMeasurement", "number")
    pattern_generator.physical_process("Substrate", views={"edit"})
    pattern_generator.physical_process("Structuring", views={"edit"})
    pattern_generator.physical_process("SolarsimulatorMeasurement")

Here, you can simply remove a line and the process is gone.  Well, not
entirely: You still need to remove its views module, templates, and models in
order to have everything neat and clean.  But removing the URL is enough for
the moment.


Adding a new process module
=================================

So you want to add a new measurement device or manufacturing process to your
JuliaBase installation.  You do so by adding new models, views, URLs, and
possibly an electronic lab notebook to your app “institute”.

I will show how to do that step-by-step.  In this example case, we write the
code for layer thickness measurements.

Overview
------------

The following steps are necessary for creating a physical process:

#. Create a database model in ``institute/models.py``.
#. Create links in ``urls.py``.
#. Create a view module in ``samples/views/``.  Fill the view module with an
   “edit” and a “show” function.
#. Create an “edit” and a “show” template in ``templates/``.
#. *(Optional)* Create an electronic lab notebook.
#. *(Optional)* Create support for the new process in the Remote Client.
#. *(Optional)* Import legacy data.

In general, you will not do all of this from scratch.  Instead, you will
copy-and-paste from an already existing process which is as similar to the new
one as possible.  (By the way, a little bit of code duplication in this area is
not really bad.)


Creating the database models
-----------------------------------

A “database model” or simply a “model” is a class in the Python code which
represents a table in the database.  It defines which things need to be stored
for every thickness measurement.  Since a model is a very Django-specific
construction, see the `Django model documentation`_ for the details.

.. _`Django model documentation`: https://docs.djangoproject.com/en/dev/topics/db/models/

Let us assume that your thickness measurements need two fields: The measured
thickness and the method that was used to measure the thickness.  For the
method, you want to give the user the choice between five pre-set methods.

Thus, add the following code to your ``models.py``::

    methode_choices=((u"profilers&edge", _(u"profilers + edge")),
		     (u"ellipsometer", _(u"ellipsometer")),
		     (u"calculated", _(u"calculated from deposition parameters")),
		     (u"estimate", _(u"estimate")),
		     (u"other", _(u"other")))

    class ThicknessMeasurement(PhysicalProcess):
        thickness = models.DecimalField(_(u"layer thickness"), max_digits=6,
                                        decimal_places=2, help_text=_(u"in nm"))
        method = models.CharField(_(u"measurement method"), max_length=30, 
                                  choices=methode_choices, default="profilers&edge")

The first part defines the five choices – note that it defines pairs of
strings, namely the internal name, which will be written to the hard disk, and
the descriptive name, which will be shown to the user.  The descriptive name is
enclosed by ``_(...)`` to make it translatable to various languages.

Try to be as restrictive as is sensible when defining your models.  In
particular, mark only those fields as optional that are really optional, set
minimal and maximal values for numeric fields where applicable, and restrict
the number of digits for decimal fields.  This not only forces users to enter
plausible values, it also helps debugging.


Schema migration
................

After you add (or change) database models, you must to a so-called schema
migration.  This means that the tables in the database PostgreSQL are actually
changed, so that Django can use this new structure (a.k.a. schema).

It is a good idea to test a schema migration first on a test server.

The schema migration is created and applied by saying::

    ./manage.py makemigrations institute
    ./manage.py migrate institute

The first line will create a new file in :file:`institute/migrations/`.  It
should be added to your repository.


Creating the URLs
---------------------

The following work is done in :file:`institute/urls.py`.  This step is fairly
simple.  For the thickness measurement, you add::

    pattern_generator.physical_process("LayerThicknessMeasurement")


Creating the view
-----------------

Typically, the view is the most complex task when creating a new kind of
process.  The Python file containing it must be called
:file:`{process_class}.py`, thus in the current example,
:file:`layer_thickness_measurement.py`.  It contains three parts:

#. The form(s).
#. The validation routines.
#. The ``def edit(request, ...)`` function.  This is mandatory.


The form
........

For such a simple process class, this is simple::

    class LayerThicknessForm(form_utils.ProcessForm):
        class Meta:
            model = LayerThicknessMeasurement
            fields = "__all__"


Validation
..........

The valdation function have turned out to be a practical approach to structure
the view module, but you may do it completely differently.  We usually define
two functions.  This first one,

::

    def is_all_valid(sample_form, layer_thickness_form, edit_description_form):
        all_valid = layer_thickness_form.is_valid()
        all_valid = sample_form.is_valid() and all_valid
        if edit_description_form:
            all_valid = edit_description_form.is_valid() and all_valid
        return all_valid

returns ``True`` if all forms validate.  For some processes, there is a lot of
forms, however for thickness measurements, ``is_all_valid`` is pretty
tractable.

The second function,

::

    def is_referentially_valid(layer_thickness_form, sample_form, process_id):
        return form_utils.measurement_is_referentially_valid(
            layer_thickness_form, sample_form, process_id, LayerThicknessMeasurement)

returns ``True`` if the data of all forms is valid in relation to each other
(for example, the deposition has at least one layer).  Here, we can rely solely
on :py:func:`~institute.views.form_utils.measurement_is_referentially_valid`.


View function
.............

You only need to create a view function for *editing*, which can also be used
to *adding*.  (The *display* of an existing process is handled by JuliaBase.)
This view function must be defined like this::

    def edit(request, layer_thickness_measurement_id):
        ...

The name of the second parameter must be adapted to the respective process, and
in general takes the form :samp:`{process_class}_id`.  If the process class
defines an “identifying field”, the second parameter must be called like it.
See the PDS measurement as an example for the latter.


.. note:: Django discourages conventions, and instead has “explicit is better
   than implicit” as its mantra.  JuliaBase respects this, however for views of
   processes, it introduces the naming conventions explained here.  Processes
   are similar enough to each other that one would get too much redundancy
   otherwise.

The general outline of a view function is:

#. Look up process in the DB
#. Check for sufficient permissions
#. If HTTP method is POST:
    #. Build forms from POST data
    #. If forms are valid:
        #. Save everything
        #. Generate feed notification
        #. Return by calling :py:func:`~samples.views.utils.successful_response`
#. If HTTP method is GET:
    #. Build forms, maybe with initial values
#. Return by calling :py:func:`django.shortcuts.render`

You can see this outline in action in
:py:func:`institute.views.samples.layer_thickness_measurement.edit`.


Creating the templates
----------------------

You need two templates per process, one that is called
:file:`edit_{process_name}.html` and the other that is called
:file:`show_{process_name}.html`.  Copy them from the process which is most
closely related to the one you're editing and apply the necessary
modifications.  Put them into the directory
:file:`institute/templates/samples/`.


A more complex example: Writing a deposition module
===========================================================

I will show how to write a module for a deposition system by creating an
example module step-by-step.  In this case, I show how I write the module for
the small cluster tool in the IEF-5.


The models
-------------

A deposition system typically needs two models: One for the deposition data and
one for the layer data.  The layer data will carry much more fields than the
deposition, and it will contain a pointer to the deposition it belongs to.
This way, deposition and layers are kept together.  This pointer is represented
by a “foreign key” field.

In case of the cluster tool, things are slightly more complicated because the
layers are not of one kind.  Instead, we can have a PECVD layer or a hotwire
layer.  Both have very different data.  Normally though, all layers share the
very same attributes.  This is much simpler.

Anyway, in order to cope with the multiple layer types, I have to introduce a
common base class for the two layer types.  This is not an abstract class in
Django terminology but a concrete one because I need a single reverse foreign
key from the deposition instance to the set of layers, and therefore, an
intermediate database table is needed.

Thus, we have the following model structure::

    Deposition  ---->  SmallClusterToolDeposition

    Layer  -->  SmallClusterToolLayer  --+-->  SmallClusterToolHotwireLayer
                                         |
                                         `-->  SmallClusterToolPECVDLayer

The deposition model
.........................

Basically, one can copy-and-paste the deposition model class for another
deposition and thoroughly apply the necessary modifications to it.

Its ``Meta`` class should be::

    class Meta:
        verbose_name = _(u"small cluster tool deposition")
        verbose_name_plural = _(u"small cluster tool depositions")
        _ = lambda x: x
        permissions = (("add_small_cluster_tool_deposition",
                       _("Can add small cluster tool depositions")),)

It is very important that it defines those permissions because it is derived
from ``Process`` (albeit indirectly).  Note that the first string must match
the pattern ``add_process_name_with_underscores``.

Then, we need two methods to get URLs for a depositions::

    def get_absolute_url(self):
        return django.core.urlresolvers.reverse("samples.views.small_cluster_tool_deposition.show",
                args=(urlquote(self.number, safe=""),))

    @classmethod
    def get_add_link(cls):
        _ = ugettext
        return django.core.urlresolvers.reverse("add_small_cluster_tool_deposition")

The view function ``"samples.views.small_cluster_tool_deposition.show"`` as
well as the symbolic name for a view function
``"add_small_cluster_tool_deposition"`` must exist in ``urls.py``, see below.

In order to enable users to duplicate and edit existing depositions, you should
also add the following method::

    def get_additional_template_context(self, process_context):
        layers = []
        for layer in self.layers.all():
            try:
                layer = layer.smallclustertoolhotwirelayer
                layer.type = "hotwire"
            except SmallClusterToolHotwireLayer.DoesNotExist:
                layer = layer.smallclustertoolpecvdlayer
                layer.type = "PECVD"
            layers.append(layer)
        result = {"layers": layers}
        if permissions.has_permission_to_add_physical_process(
                process_context.user, self):
            result.update({"edit_url": django.core.urlresolvers.reverse(
                                   "edit_small_cluster_tool_deposition",
                                   kwargs={"deposition_number": self.number}),
                           "duplicate_url": "%s?copy_from=%s" % (
                        django.core.urlresolvers.reverse("add_small_cluster_tool_deposition"),
                        urlquote_plus(self.number))})
        return result

This is a somewhat peculiar method.  It is used when the HTML for a process (in
this case a deposition) is created.  Its return value is a dictionary which is
combined with the dictionary sent to the “show-process” template.  This way,
additional program logic can be used to generate the HTML.  In case of
depositions, an “edit” and “duplicate” button are added, depending on the
user's permissions.

However, in the special case of a cluster tool deposition, I also place the
layers into this template context.  The reason is that this way, I can inject a
``type`` attribute into the layers which is useful when rendering it by the
template code.

Finally, with

::

    default_location_of_deposited_samples[SmallClusterToolDeposition] = \
            _(u"large-area deposition lab")
    admin.site.register(SmallClusterToolDeposition)

I declare that the default sample location for samples deposited in the small
cluster tool is the “large-area deposition lab”, and I register the model with
Django's admin interface so that it can be seen and modified there.


The layer base model
....................

This section describes something which is special to the cluster tools.  The
problem is that cluster tools have heterogeneous layers, e.g. hotwire and PECVD
layers in one deposition run.  Therefore, we need a common base class for
layers in order to have one single connection point between depositions and
their layers.

It looks like this::

    class SmallClusterToolLayer(Layer):
	deposition = models.ForeignKey(SmallClusterToolDeposition, related_name="layers",
                                       verbose_name=_(u"deposition"))

	class Meta(Layer.Meta):
	    unique_together = ("deposition", "number")
	    verbose_name = _(u"small cluster tool layer")
	    verbose_name_plural = _(u"small cluster tool layers")

By the way, this ``unique_together`` is necessary for all concrete models
directly derived from ``Layer``, as is the ``deposition field``.  The reason is
that ``Layer`` itself is an abstract class and can't contain these things.


The hotwire layer model
.......................

I'll now show the addition of the Layer model.  Since we have two, I only show
the *hotwire* layer.  The PECVD is not much different.

First, for some models, you need so-called “choices” tuples.  For hotwire
layers, this is only one, namely for the wire material::

    small_cluster_tool_wire_material_choices = (
	("Rhenium", _("Rhenium")),
	("Tantal", _("Tantalum")),
	("Tungsten", _("Tungsten")),
    )

Put these “choices” tuples right before the respective model class.  See the
Django documentation for more about this.  However, I'd like to point out that
very often you have to make the second item translatable by putting it in
``_(...)``.

Now for the fields::

    class SmallClusterToolHotwireLayer(SmallClusterToolLayer):
	pressure = models.CharField(_(u"deposition pressure"), max_length=15,
                                    help_text=_(u"with unit"), blank=True)
	time = models.CharField(_(u"deposition time"), max_length=9,
                                help_text=_(u"format HH:MM:SS"), blank=True)
	substrate_electrode_distance = \
	    models.DecimalField(_(u"substrate–electrode distance"),
                                null=True, blank=True, max_digits=4,
				decimal_places=1, help_text=_(u"in mm"))
	comments = models.TextField(_(u"comments"), blank=True)
        ...

As you can see, every field starts with its name, marked as translatable.
Optional text fields just have a ``blank=True`` in their parameter list.

The rest is standard.

::

	class Meta(SmallClusterToolLayer.Meta):
	    verbose_name = _(u"small cluster tool hotwire layer")
	    verbose_name_plural = _(u"small cluster tool hotwire layers")

    admin.site.register(SmallClusterToolHotwireLayer)

Adds the singular/plural name of this model to the model (also for
internationalisation), and register the model on the admin pages.

And that's it.  The models are done now.


Creating the URLs
---------------------

For the small cluster tool, we add to ``urls.py``::

    url(r"^small_cluster_tool_depositions/add/$",
        "samples.views.small_cluster_tool_deposition.edit",
	{"deposition_number": None}, "add_small_cluster_tool_deposition"),
    url(r"^small_cluster_tool_depositions/(?P<deposition_number>.+)/edit/$",
	"samples.views.small_cluster_tool_deposition.edit", 
        name="edit_small_cluster_tool_deposition"),
    (r"^small_cluster_tool_depositions/(?P<deposition_number>.+)",
     "samples.views.small_cluster_tool_deposition.show"),

I took this from an already existing deposition and wrote the new names into
it.  We also want to provide a lab notebook, so we append::

    url(r"^small_cluster_tool_depositions/lab_notebook/(?P<year_and_month>.*)/export/",
	"samples.views.lab_notebook.export", {"process_name": "SmallClusterToolDeposition"},
	"export_lab_notebook_SmallClusterToolDeposition"),
    url(r"^small_cluster_tool_depositions/lab_notebook/(?P<year_and_month>.*)",
	"samples.views.lab_notebook.show", {"process_name": "SmallClusterToolDeposition"},
	"lab_notebook_SmallClusterToolDeposition"),


Creating the views
---------------------

I take the 6-chamber deposition as a guide and copy-and-paste it.


The forms
.........

In contrast to non-cluster-tool modules, I need to add a custom
``AddMyLayerForm`` class because adding a new layer is different from other
deposition systems since you have to give the *type* of the new layer.  Thus::

    new_layer_choices = (
	("hotwire", _(u"hotwire")),
	("PECVD", _(u"PECVD")),
	("none", _(u"none")),
	)

    class AddLayersForm(forms.Form):
	_ = ugettext_lazy
	layer_to_be_added = forms.ChoiceField(
                label=_(u"Layer to be added"), required=False, widget=forms.RadioSelect,
		choices=new_layer_choices)
	my_layer_to_be_added = forms.ChoiceField(
                label=_(u"Nickname of My Layer to be added"), required=False)

        ...

This is not more than a modified version of the class of the same name from
``form_utils.py``.

The deposition form can largely be copied from the 6-chamber deposition.  In
principle, this is also true for the two layer models, however, the attributes
and validation conditions must be carefully adapted of course.  Moreover, I add
an extra, hidden ``TextInput`` field called ``layer_type`` which saves the
layer type when creating the HTML form, so that it can be re-constructed when
scanning POST data::

    class HotwireLayerForm(forms.ModelForm):
	layer_type = forms.CharField(widget=forms.HiddenInput, initial=u"hotwire")
	...

Then, I need a ``ChangeLayerForm`` which contains the controls for duplicating
or removing a layer::

    class ChangeLayerForm(forms.Form):
	_ = ugettext_lazy
	duplicate_this_layer = forms.BooleanField(label=_(u"duplicate this layer"), required=False)
	remove_this_layer = forms.BooleanField(label=_(u"remove this layer"), required=False)
	move_this_layer = forms.ChoiceField(label=_(u"move this layer"), required=False,
					    choices=(("", _(9*u"-")), ("up", _(u"up")), ("down", _(u"down"))))

	def clean(self):
	    _ = ugettext
	    operations = 0
	    if self.cleaned_data["duplicate_this_layer"]:
		operations += 1
	    if self.cleaned_data["remove_this_layer"]:
		operations += 1
	    if self.cleaned_data.get("move_this_layer"):
		operations += 1
	    if operations > 1:
		raise ValidationError(_(u"You can't duplicate, move, or remove a layer at the same time."))
	    return self.cleaned_data


The FormSet
...............

Now we're ready to create the ``FormSet`` class which is basically a container
for methods that are used to manage the forms.  In order to avoid being forced
to pass all the forms and form lists to all of these routines, they are not
functions but methods, and the forms and form lists are instance variables of
the ``FormSet``.

By and large, also the ``FormSet`` can be copied from another deposition system
and carefully adopted.  In the case of the small cluster tool, most
modifications are due to the prlymorphic layers.

The first peculiarity is a dummy ``LayerForm`` class which is only to detect
the layer type when constructing forms from POST data, using the above
mentioned ``layer_type``::

    class LayerForm(forms.ModelForm):
        layer_type = forms.CharField()

I cannot explain all modification that are necessary but exemplarily, have a
look at the auxiliary routine ``build_layer_and_channel_forms``::

    def build_layer_and_channel_forms(deposition):
	self.layer_forms = []
	for index, layer in enumerate(deposition.layers.all()):
	    if hasattr(layer, "smallclustertoolhotwirelayer"):
		self.layer_forms.append(HotwireLayerForm(prefix=str(index),
                                        instance=layer.smallclustertoolhotwirelayer))
	    else:
		self.layer_forms.append(PECVDLayerForm(prefix=str(index),
                                        instance=layer.smallclustertoolpecvdlayer))

Here, you can see how I distinguish between the two layer types.

Furthermore, it's important that I don't let the user enter a layer number.
The ordering of the layers is simply determined by their ordering in the
webpage's form set.  I add the layer number in the ``save_to_database`` method.


The view functions
......................

You need an ``edit`` and a ``show`` view function.  They are really
straightforward.  Just copy them from another deposition module and modify them
slightly.  (Actually, this code duplication is a candidate for a common base
function but I'd like to implement more deposition systems just to be sure.)

Glossary
===========

.. glossary::

   process
      Anything that contains information about a sample.  This can be a process
      in the literal meaning of the word, i.e. a deposition, an etching, a
      clean room process etc.  It can also be a measurement or a result.
      However, even the substrate, sample split, and sample death are
      considered processes in JuliaBase.

      It may have been better to call this “history item” or just “item”
      instead of “process”.  The name “process” is due to merely historical
      reasons, but there we go.

   measurement
      A special kind of *process* which contains a single measurement.  It
      belongs to the class of *physical processes*.

   physical process
      A deposition or a measurement process.  Its speciality is that only
      people with the right permission for a certain physical process are
      allowed to add and edit physical processes.

   result
      A result – or result process, as it is sometimes called in the source
      code – is a special process which contains only a remark, a picture, or a
      table with result values.

